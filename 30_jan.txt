class Solution {
  public:
    void rearrangeQueue(queue<int> &q) {
        if (q.empty()) return;

        int n = q.size();
        int half = n / 2;
        stack<int> s;

        // Step 1: Push the first half of the queue into the stack
        // Q: [1, 2, 3, 4] -> S: [1, 2] (Top is 2), Q: [3, 4]
        for (int i = 0; i < half; i++) {
            s.push(q.front());
            q.pop();
        }

        // Step 2: Enqueue the stack elements back into the queue
        // This reverses the order of the first half at the back of the queue
        // Q: [3, 4, 2, 1]
        while (!s.empty()) {
            q.push(s.top());
            s.pop();
        }

        // Step 3: Dequeue the first half (original second half) and enqueue it back
        // This moves the reversed first half to the front
        // Q: [2, 1, 3, 4]
        for (int i = 0; i < half; i++) {
            q.push(q.front());
            q.pop();
        }

        // Step 4: Push the first half (which is the reversed first half) into the stack again
        // Q: [3, 4], S: [2, 1] (Top is 1)
        for (int i = 0; i < half; i++) {
            s.push(q.front());
            q.pop();
        }

        // Step 5: Interleave the elements from the stack and queue
        // Stack top has the 1st element, Queue front has the (N/2 + 1)th element
        while (!s.empty()) {
            q.push(s.top());    // Push from stack
            s.pop();
            q.push(q.front());  // Push from queue
            q.pop();
        }
    }
};