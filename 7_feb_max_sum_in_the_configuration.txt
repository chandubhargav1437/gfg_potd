class Solution {
  public:
    int maxSum(vector<int> &arr) {
        // code here
        long long n = arr.size();
        if (n == 0) return 0;

        // Use long long for sums to avoid overflow during calculation
        long long array_sum = 0;
        long long current_val = 0;

        // Step 1: Calculate the sum of the array and the initial weighted sum
        for (int i = 0; i < n; i++) {
            array_sum += arr[i];
            current_val += (long long)i * arr[i];
        }

        // Initialize max_val with the current (0th rotation) value
        long long max_val = current_val;

        // Step 2: Iterate to calculate the value for subsequent rotations
        // Logic: Next_Val = Current_Val + Array_Sum - (N * Element_that_wrapped_around)
        for (int i = 1; i < n; i++) {
            // In the i-th rotation, the element moving from index (n-1) to index 0
            // is the one at index (n - i) in the original array.
            current_val = current_val + array_sum - (n * arr[n - i]);
            
            if (current_val > max_val) {
                max_val = current_val;
            }
        }

        return (int)max_val;
        
    }
};